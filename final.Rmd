---
title: "final project"
author: "Aiying Huang"
date: "2023-12-01"
output: 
  pdf_document:
    latex_engine: xelatex
---


# 描述性统计

## 变量分布

```{r}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(GGally)
library(gridExtra)

# Read the data
data <- read.csv("./Project_1_data.csv")

# 1. Descriptive statistics table for all variables
summary(data)

# 2. Explore distribution of results and consider potential transformations
# Histograms for continuous variables
hist_math <- ggplot(data, aes(x = MathScore)) + geom_histogram(bins = 30) + ggtitle("Histogram of Math Scores")
hist_reading <- ggplot(data, aes(x = ReadingScore)) + geom_histogram(bins = 30) + ggtitle("Histogram of Reading Scores")
hist_writing <- ggplot(data, aes(x = WritingScore)) + geom_histogram(bins = 30) + ggtitle("Histogram of Writing Scores")

# Boxplots for continuous variables to check for outliers
box_math <- ggplot(data, aes(y = MathScore)) + geom_boxplot() + ggtitle("Boxplot of Math Scores")
box_reading <- ggplot(data, aes(y = ReadingScore)) + geom_boxplot() + ggtitle("Boxplot of Reading Scores")
box_writing <- ggplot(data, aes(y = WritingScore)) + geom_boxplot() + ggtitle("Boxplot of Writing Scores")

# Grid of plots
grid.arrange(hist_math, hist_reading, hist_writing, box_math, box_reading, box_writing, ncol = 3)

# 3. Check for potential outliers or influential points
# Scatterplot matrix for continuous variables
ggpairs(data, columns = c("MathScore", "ReadingScore", "WritingScore"))

```


## 缺失值

```{r}
# Load necessary libraries
library(ggplot2)
library(reshape2)


# Creating a function to count NA and empty strings as missing values
count_missing <- function(x) sum(is.na(x) | x == "")
# Calculating the missing values
missing_values <- sapply(data, function(x) count_missing(x))

# Creating a dataframe for missing values
missing_data_frame <- data.frame(Variable = names(missing_values), MissingValues = missing_values)

# Convert empty strings to NA
data[data == ""] <- NA

# Melt the data for visualization
melted_data <- melt(data.frame(row = 1:nrow(data), data), id.vars = 'row')

# Creating the heatmap
ggplot(melted_data, aes(x = variable, y = row)) + 
  geom_tile(aes(fill = is.na(value))) + 
  scale_fill_manual(values = c('white', 'red'), guide = FALSE) + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = 'Variables', y = 'Observation Rows', title = 'Missing Data Heatmap')
```
```{r}
missing_data_frame
```




# 数据预处理

## 缺失值填补

```{r}
# Imputing missing values
# For columns with fewer missing values, replace with mode
get_mode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

data$PracticeSport[is.na(data$PracticeSport)] <- get_mode(data$PracticeSport)
data$IsFirstChild[is.na(data$IsFirstChild)] <- get_mode(data$IsFirstChild)

# For columns with more missing values, you can choose to impute or drop
# Imputing with mode (as an example)
data$EthnicGroup[is.na(data$EthnicGroup)] <- get_mode(data$EthnicGroup)
data$ParentEduc[is.na(data$ParentEduc)] <- get_mode(data$ParentEduc)
data$TestPrep[is.na(data$TestPrep)] <- get_mode(data$TestPrep)
data$ParentMaritalStatus[is.na(data$ParentMaritalStatus)] <- get_mode(data$TestPrep)
data$WklyStudyHours[is.na(data$WklyStudyHours)]<- get_mode(data$WklyStudyHours)
data$NrSiblings[is.na(data$NrSiblings)] <- mean(data$NrSiblings,na.rm = TRUE)

# Alternatively, to drop rows with NA values in these columns-TransportMeans
data <- data %>% drop_na(TransportMeans)
```


```{r}
# Creating a function to count NA and empty strings as missing values
count_missing <- function(x) sum(is.na(x) | x == "")
# Calculating the missing values
missing_values <- sapply(data, function(x) count_missing(x))

# Creating a dataframe for missing values
missing_data_frame <- data.frame(Variable = names(missing_values), MissingValues = missing_values)
missing_data_frame
```





# 检查变量之间的边际分布和成对关系-correlation/pairwise-带修改完善




# 模型构建

```{r}
# Load necessary libraries
library(tidyverse)
library(caret)
library(car)

set.seed(123) 
splitRatio <- 0.8

trainIndex <- sample(seq_len(nrow(data)), size = floor(splitRatio * nrow(data)))
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]

# Splitting the train dataset into independent variables (X) and dependent variables (Y)
X_train <- trainData %>% select(-c(MathScore, ReadingScore, WritingScore))
Y_math_train <- trainData$MathScore
Y_reading_train <-trainData$ReadingScore
Y_writing_train <- trainData$WritingScore
```

## add interation-这里还要修改

```{r}
# Checking for interaction effects (example for math score)
full_model_math_interaction <- lm(Y_math_train ~  (.)^2, data = X_train)
full_model_reading_interaction <- lm(Y_reading_train ~  (.)^2, data = X_train)
full_model_writing_interaction <- lm(Y_writing_train ~  (.)^2, data = X_train)
```

## 模型选择

```{r}
# backward (compare)
AICmodel_math_interaction = 
  step(full_model_math_interaction, trace = 0, direction='backward')
BICmodel_math_interaction = 
  step(full_model_math_interaction, scale = log(nrow(X_train)), trace = 0, direction='backward')

#参数全部输出有点太多了，仅仅输出参数数量进行对比
num_params_AICmodel <- length(coef(AICmodel_math_interaction))
num_params_BICmodel <- length(coef(BICmodel_math_interaction))

cat("AIC Model Parameters:", num_params_AICmodel, "\n")
cat("BIC Model Parameters:", num_params_BICmodel, "\n")

```

```{r}

#此处解释因为bic做准则比aic的变量多，我们倾向选择变量少的
model_math_interaction = AICmodel_math_interaction
model_reading_interaction =
  step(full_model_reading_interaction, trace = 0, direction='backward')
model_writing_interaction =
  step(full_model_writing_interaction, trace = 0, direction='backward')

# results
# r.squared..
glance_math = broom::glance(model_math_interaction) |>
  mutate(model = "Math") |>
  select(model, r.squared, adj.r.squared, p.value, AIC, BIC) 

glance_reading = broom::glance(model_reading_interaction) |>
  mutate(model = "Reading") |>
  select(model, r.squared, adj.r.squared, p.value, AIC, BIC) 

glance_writing = broom::glance(model_writing_interaction) |>
  mutate(model = "Writing") |>
  select(model, r.squared, adj.r.squared, p.value, AIC, BIC) 

bind_rows(glance_math, glance_reading, glance_writing) |>
  knitr::kable()
  
# coef
broom::tidy(model_math_interaction) |>
  knitr::kable(caption = "Math")
broom::tidy(model_reading_interaction) |>
  knitr::kable(caption = "Reading")
broom::tidy(model_writing_interaction) |>
  knitr::kable(caption = "Writing")
```

```{r}
par(mfrow=c(2,2))
plot(model_math_interaction) 
mtext("Math Model Diagnostic", outer = TRUE, cex = 1, line = -1)

plot(model_reading_interaction)
mtext("Reading Model Diagnostic", outer = TRUE, cex = 1, line = -1)

plot(model_writing_interaction)
mtext("Writing Model Diagnostic", outer = TRUE, cex = 1, line = -1)

```
## selected model



